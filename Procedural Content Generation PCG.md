A tool to programmatically generate [[Asset]] instances,
using point sources, called samplers, and filtering to position them and spawners to create them.
The generation is implemented using [[Visual Script]].

PCG is implemented as a [[Plugin]], enabled at [[Top Menu Bar]] > Edit > Plugins > Procedural Content Generation Framework (PCG).
There is also a utility plugin name Procedural Content Generation Framework (PCG) Geometry Script Interop.
See [[Geometry Script]].

The general flow is that points are generated by a sampler, modified and filtered by various nodes, and then passed to spawners to create objects in the [[Level]].

There are input and output nodes in the PCG graph, but they are optional.
They are used to pass points between PCG graphs.
Useful when having a hierarchy of PCGs, the parent can read the output points of the children.
See _Hierarchical PCG_ below.

# Create A PCG Graph

A PCG Graph is an [[Asset]] in the [[Content Browser]].
Create with [[Content Browser]] > right-click > PCG > PCG Graph.
PCG Graph [[Asset]]s often has a name starting with `PCG_`.
To add an instance of the PCG Graph to the [[Level]] drag it from the [[Content Browser]] to the [[Level Viewport]].
This creates a PCG Volume [[Actor]] instance.

A good way to learn and discover what can be done in PCG is to study one of the existing PCG graphs included in the engine and sample projects.


# PCG Graph Editor

The PCG Graph is a [[Visual Script]].
It is edited in the PCG Graph Editor.
Has a Palette panel with all the nodes that can be used.
Has a [[Details Panel]] showing the settings of the currently selected node,
or the PCG Graph itself if no node is selected.
Has a Graph panel where nodes are created and connected.
Nodes are created either by dragging them from the Palette panel or by right-click in the Graph panel.
Has a Preview panel (Name?) that is used to inspect the values of data as it flows through the graph.

It has an Input node and an Output node.

Changes made in the PCG Graph Editor show up immediately on instance in the [[Level Viewport]],
so it is helpful to keep one in view while editing.

Nodes can be temporarily disabled, i.e. toggle evaluation, by hitting E on the keyboard.
This is useful on Spawner nodes for hiding the thing they spawn, making it easier to see what is going on when working with points earlier in the network.

## Keyboard shortcuts

- E: Toggle evaluation of the selected node.
	- Node becomes grayed out.
- D: Toggle debugging rendering of point output of the selected node.
	- Node gets a teal icon in the top-left corner.
- A: Inspect. The node's output is listed in the Inspect panel.
	- The node gets yellow icon.

# Point

A point is the fundamental unit of information in PCG.
Most nodes create, manipulate, or consume points.

## Properties

A point has a set of mandatory data, called Properties.
The Properties are:
- Transform.
- Density.
- Bounds Min.
- Bounds Max.
- Color.
- Steepness.
	- Don't know what this is. Density gradient across the bounds?
- Seed.

A point has a scale, which is used by Static Mesh Spawner to set the scale of the spawned Static Mesh Instance.

A point has a density, which is a scalar value.
Can be used to filter and prune points before they reach a Spawner.

We can inspect the environment around a point and use that to assign a density to the point.
For example, we can set a point's density to the dot product between a mesh's surface normal and the up vector to get higher density on top of an object and lower density on the sides and below.
This is done with the Normal To Density node.
(
At least that is what I think it does.
We pass it points and in the [[Details Panel]] we set a normal.
)

Filtering is done with the Density Filter node.
It has a range of density values and a toggle for either accepting or rejecting points within that range.

## Attributes / Metadata

A point has a set of optional data, called attributes or metadata.
A PCG graph that transform points must take care to always propagate the attributes or else they are lost.
The Copy Point has a Copy Metadata boolean input.
(
How does one propagate attributes in general?
Does the Transform Point node copy the attributes?
)

For example, a point can carry a [[Material]] and a [[Static Mesh]].

To add an attribute to a set of points you need a PCG Point Data.
(Not sure what that is yet, or how to get one.)
The Mutable Metadata node will give you the metadata for the point data.
The metadata contains the attributes.
The Create (Vector|String|...) Attribute node will create a new attribute of type Vector.
This can be done from the Execute With Context of a _Blueprint Extension_,
before calling Iteration Loop to actually populate the newly created attributes.
In Iteration Loop Body use Set (Vector|String|...) Attribute to set the attribute for a particular particle.

# Point Samplers

A central concept in PCG is points.
Points are generated by Samplers.
- Mesh Sampler: Generates points on the surface of a [[Static Mesh]].
- Spline Sampler: Generate points along a [[Spline Component]].


## Mesh Sampler

Requires the Procedural Content Generation Framework (PCG) Geometry Script Interop plugin to be enabled.

Has [[Details Panel]] > Settings > Static Mesh that should be set to the [[Static Mesh Asset]] to generate point on.

Has [[Details Panel]] > Settings > Sample Method:
- One Point Per Triangle: 
- One Point Per Vertex:
- Poisson Sampling: 

Can do voxelization by enabling [[Details Panel]] > Voxelize Options > Voxelize.
Places a regular grid over the mesh and sample one point per grid cell.
Set Voxel Size to get the amount and density of points you need.

## Spline Sampler

Sample points along a spline.
Typically used together with a [[Spline Component]] in the same [[Actor]] as the PCG Component and a Get Spline Data (Self) node.

[[Details Panel]] > Settings > Mode:
- Subdivision: Sample according to the spline's control points. Not sure how though.
- Distance: Sample along the spline at even intervals. The distance is set with Distance Increment just below Mode in the [[Details Panel]].

Output of the Spline Sampler node is a set of points.


# Point Manipulation

## Transform Points

Translate, rotate, and scale points, with some randomness.
A point's scale is used by Static Mesh Spawner to set the scale of the spawned Static Mesh Instance.


## Copy Points

(
Not sure what this does really, describing how it was used in the [Unreal Fest 2023 PCG introduction presentation](https://youtu.be/LMQDCEiLaQY?t=1186).
)

Transform points from one coordinate system to another.
Has two inputs:
- Source: The points to transform from world space to the target space.
- Target: The target space.

The output is the Source points transformed to be around the Target points instead.
If there are many Target points then the Input points are duplicated for each.

The Target can be the location of an [[Actor]] to make the points be around that [[Actor]].
See _Get Actor Data_ below.

## Point Filter

Split the input points into two sets according to a predicate.
We get the `true` set and the `false` set.
Called the Inside Filter and the Outside Filter, respectively.

## Merge

Take two sets of points and merge them to a single set.

## Point Filter > Merge

We can use Filter and Merge together to modify a subset of a set of points.
Use a Point Filter node to extract the set of points that should be modified.
Route the Inside Filter through a set of point modification nodes, such as Projection or Transform Point.
Route both the output of the last modification node and the Outside Filter output of the Point Filter node to a Merge node.
The effect is that we start with a set of point, split them in two sets based on a predicate, modified one of the sets but left the other unchanged, and then merged them back to a single set again.

## Spatial Noise

Can be set to one of several modes with [[Details Panel]] > Settings > Mode.
- Perlin 2D
- Caustic 2D
- Voronoi 2D
- Fractional Brownian 2D
- Edge Mask 2D

May need to set Transform > Scale very large, multiple hundreds, for the noise pattern to show up.


## Arithmetic

Add, subtract, multiply, etc.
Must specify which attribute of the inputs that should be operated on.
This is done at [[Details Panel]] > Input > Input Source \[12\].
Can be
- Density
- Bounds (Min|Max)
- Extents
- Color
- and more.

I don't know what happens to the other attributes.
Is the data from A used?
Does the output only have density?


## Distance

Compute the distance between a set of Source points and a set of Target points.
Don't know how the two sets are combined.
Don't know what happens if the two sets don't have the same number of points.


## Attribute Noise

Apply noise to a particular point attribute.
Have a set of operators that can be applied between the source attribute value and the noise value:
- Minimum
- Maximum
- Add
- Multiply
- and more.

The output can be different from the input.
(Haven't tested the following, I'm speculating.)
For example, we can take the Z coordinate, multiply by some noise value, and then write to density.
Then we get high density at the top and low density at the bottom of the point cloud.

## Normal To Density

Modifies the densities of the incoming points so that those that have a normal aligned with the normal set in the Normal To Density node's [[Details Panel]] get a high density,
while points with a normal orthogonal to the target normal get a low density.

## Merge

A node to which any number of points wires can be connected to the input pin.
All those points will be passed to the output.
Useful when we have multiple paths each with a Static Mesh Spawner, a Mesh Sampler, and a Copy Points.
Merge makes it so that we get points on all of the meshes.

## Projection

Don't know yet.

# Spawners

The purpose of a PCG graph is to instantiate things, i.e. to spawn them.
A Spawner node takes a set of points as input and generates a set of instances as output.
Different types of spawners have different types of outputs.
For example, the Static Mesh Spawner outputs [[Static Mesh]]es.

The spawned instances are placed relative to the owning PCG Volume.
Or maybe not, maybe it is in world space.

The scale of the spawned thing is determined by the scale of the point given to the Spawner.

## Static Mesh Spawner

Spawns a [[Static Mesh]] at the input points.
The mesh to spawn is selected in different ways depending on what [[Details Panel]] > Settings > Mesh Selector Type is set to.

### PCG Mesh Selector Weighted

Can have a selection of [[Static Mesh Asset]]s to randomly select from,
based on a weighted random distribution.

The set of [[Static Mesh Asset]]s that the Static Mesh Spawner selects among is set at [[Details Panel]] > Settings > Mesh Entries, which is an array.
Each element has:
- Static Mesh: The [[Static Mesh Asset]] to instantiate when this element is selected for a point.
- Weight: How likely this entry is to be selected for an  input point.

### PCG Mesh Selector By Attribute

Reads the mesh to spawn from each point's Mesh (Name?) attribute / metadata.
Used when creating a _Configurable PCG Level Instance_.


## Spawn Actor

Spawn an [[Actor]] for every input point.
Has [[Details Panel]] > Settings > Template Actor Class which is the [[Actor]] type to spawn.
After spawning the Spawn Actor node can call functions on the newly created instance by adding the names of the functions to call to [[Details Panel]] > Settings > Post Spawn Function Names.

Has [[Details Panel]] > Settings > Actor Overrides.
Not sure what this does.
What is being overridden?
What happens with that data later?
Where does it takes the data from? Metadata > Attributes?


# World Inspection

PCG contains a bunch of nodes for inspecting the world.

## Get Actor Data

Get information about [[Actor]]s in the [[Level]].
Which [[Actor]] or [[Actor]]s is controlled with [[Details Panel]] > Settings > Actor Filter.
By default it inspects itself, the PCG Volume [[Actor]].
Can also be set to All World Actors.
In this mode we set Actor Selection to By Tag.
This is the [[Actor Tag]] that will be put on the [[Actor]]s we want to get data from.

[[Details Panel]] > Settings > Mode controls what in the [[Actor]] the node gets data for.
- Parse Actor Components: Get data for all [[Actor Component]]s in the [[Actor]].
- Get Single Point: Get the world location of the [[Actor]].
- Get Data From Property: Don't know.
- Get Data From PCG Component: Don't know.
- Get Data From PCG Component Or Parse Components: Don't know.

The output of Get Actor Data can be connected to a Points input pin.
A To Point node will be created.


## Get Spline Data

A node that reads data from a [[Spline Component]].

When the [[Details Panel]] > Settings > Actor Filter is set to Self then the PCG Component's owning [[Actor]] will be searched for a [[Spline Component]] to read data from.
I don't know how to select a particular [[Spline Component]] if there are multiple.

The output from Get Spline Data can be passed to Spline Sampler to generate points along the spline.

## Get Landscape Data

Combine with a Projection node to move the point to the Landscape surface.
The [_Procedural Content Generation Tools in UE5: Overview and Roadmap | Unreal Fest 2023_ 40:00](https://dev.epicgames.com/community/learning/talks-and-demos/M7DW/unreal-engine-procedural-content-generation-tools-in-ue5-overview-and-roadmap-unreal-fest-2023) presentation combined this with a BP PCGE Preserve Local Z node.
I don't know if this node is included or a custom Blueprint Extension part of the demo project only.

## World Ray Hit Query

Don't know yet.

# Hierarchical PCG

## Communication between PCG Actors

One PCG graph can read the output of another PCG graph.
If that other PCG graph passes the points to the output node.
We call the PCG graph that writes to its output node the child PCG,
and the PCG graph that reads and uses those points the parent PCG.

To find the child PCG the parent PCG graph uses the Get Actor Data node.
There are several ways of using the Get Actor Data node.
One way is to set the following in the Get Actor Data node's [[Details Panel]]:
- Set Actor Filter to All World.
- Set Actor Selection to By Tag.
	- This is [[Details Panel]] > Actor > Advanced > Tag on the PCG Actor instance that we want to find.
- Set Actor Selection Tag to the tag that  you assigned to the PCG Actor instances that points should be read from.
- Set Mode to Get Data From PCG Component.
	- This is what makes is so that we read the points that the child PCG passed to its output node.
- Consider enabling Ignore Self And Children.
	- What is meant by "children"? Attached in the [[Outliner]]?
	- What happens if we don't enable this? Infinite recursion where our output points are added to our input point set ad infinitum?
- If using [[World Partition]].
	- See _PCG And World Partition_ below for more details.
	- Enable Must Overlap Self.
	- Enable Track Actors Only Within Bound.
- Connect the output of the Get Actor Data node to a To Point node.


## Nesting PCG Graphs

One PCG graph can call another PCG graph.
Similar to calling a function.
Drag the PCG graph [[Asset]] from the [[Content Browser]] into the PCG graph that should call it.
Points that the nested PCG graph pass to the output node will be available in the calling PCG graph.


# Debugging

Right-click a node, not sure which nodes support this and select Debug.
A teal icon will appear on the node and gray points will appear in the [[Level Viewport]].
There are the output points of the node.

Select an instance in the debug object drop-down menu in the tool bar.
Any node > right-click > Inspect.
A yellow icon will appear on the node.
A table of points i shown in the Inspect panel.
The number of points is shown in the top-right corner of the Inspect panel.


# PCG And World Partition

The details are unclear to me, but something along the lines of if [[World Partition]] is enabled and Is Partitioned enabled on the PCG Component that the PCG graph will be evaluated for every cell that it is in.
Whatever "is in" means.
If the graph doesn't take care to filter away points outside of its cell and those points are passed to a Spawner then every PCG instance, one per cell, will all spawn from the same set of points.
This will lead to a lot of duplicated objects created right on top of each other.

One way to prevent this is to enable Get Actor Data node > [[Details Panel]] > Settings > Must Overlap Self.
Not sure what "Self" means here.
The PCG instance, I assume, but what is its bound?
What is it that must overlap self? The [[Actor]] we are getting data from, or the points it generated?

One way to prevent this is to enable Get Actor Data node > [[Details Panel]] > Settings > Track Actor Only Within Bound.
Not sure how this differs from Must Overlap Self.

May also need to pass the points to a Cull Points Outside Actor Bounds.
Since even if the found PCG [[Actor]] itself is within the bounds, points it generate may far away, on the other side.

If there are multiple child PCG graphs that the parent PCG graph get points from then those points may be overlapping.
Discard duplicates with a Self Pruning node.
I have no idea what this does.
Can also use a Difference node.


# Blueprint Extension

We can add custom PCG graph nodes with Blueprints.

## Calling A Blueprint Extension

The node to call a Blueprint implemented node is Execute Blueprint.
In its [[Details Panel]] it has Blueprint Element Type which is the Blueprint to call.
A long list of Blueprints is included with the editor.
Several of the nodes in the Palette panel are implemented as a Blueprint and show up in this list.

Some have a circle icon, some have a circled box icon.
I don't know what these mean.

Select one and the node will change name and the [[Details Panel]] is populated with the settings for that Blueprint.

Double-click the node to open the [[Visual Script]] graph implementing the node.
This is a good way to learn and discover what can be done with a Blueprint Extension.
Create an Execute Blueprint node, set it to one of the many build-in Blueprints, and double-click to open it and see what it does.
Create a copy to get a base to start from and modify to your hearts content.

Example Blueprints that are not listed in the Palette panel:
- Mesh Sockets To Points: Emit a point for every socket on a [[Static Mesh]].
	- Must specify a [[Static Mesh Asset]] to get sockets from and a Tag that the sockets to emit points for should have.

## Creating A Blueprint Extension

We can create our own Blueprint nodes.
Create a new [[Blueprint Class]] that inherits from PCG Blueprint Element.
The operations that should be performed by the custom node are implementing by overriding functions inherited from PCG Blueprint Element.
Override a function with [[My Blueprint Panel]] > Function > Override drop-down.
- Apply Preconfigured Settings
- Execute
- Execute With Context:
	- Run once when the calling PCG graph is evaluated.
	- Call Iteration Loop to trigger calls to Iteration Loop Body.
	- Use Make PCG Tagged Data, Make Array, and Make PCG Data Collection to pass the output of Iteration Loop to the Return Node's input.
- Is Cacheable Override
- Iteration Loop Body
	- Run a number of iterations controlled  by an input pin on the node..
	- Is given the current iteration index.
	- Can access any input point.
	- See _Implementing Iteration Loop Body_ below.
- Nested Loop Body
- Node Color Override
- Node Type Override
- Point Node Body
	- Run for every point.
	- Cannot access the data for other points.
- Variable Loop Body

The node can have [[Blueprint Variable]]s.
They are created at [[My Blueprint Panel]] > Variables.
If [[Details Panel]] > Variable > Instance Editable, or the eye icon int he variable list, is enabled then that variable shows up, and is editable, in the [[Details Panel]] when an Execute Blueprint node calling this Blueprint Extension is selected,
and if the Execute Blueprint is expanded then the variables show up as input pins.

The node can have input and output pins.
These are configured at [[Class Defaults]] > [[Details Panel]] > Settings > Input & Output > Custom (Input|Output) Pins.
These are arrays.
Each array element has
- Label:
- Allowed Types:
- Allow Multiple Data:
- Allow Multiple Conne...:
- Advanced Pin:
- Tooltip:

## Implementing Iteration Loop Body

Can compute a fraction iteration progress with Iteration divided by Points, where Points is the variable passed to Iteration Loop node in Execute With Context.
Can get the location of the PCG [[Actor]] with Context > Get Original Component > Get Owner > Get Actor Transform.

A point is created with Make PCG Point.
Its details panel lists the point properties and you can enable the ones you want to specify.
The enabled properties show up as input pins on the Make PCG Point node.
One of the properties is Seed.
You should connect Compute Seed From Position to the Seed input,
and the Position input on Compute Seed From Position should be the position of the point we are about to create.
Connect the output of Make PCG point to the Point input pin on the return node.
(
Is it possible to return more than one point from an iteration?
)
It seems possible to not return any point from an iteration, by setting return node > Return Value to false.


# PCG Component

An [[Actor Component]].

Has [[Details Panel]] > Instance > Graph that is a reference to a PCG Graph [[Asset]].


# Configurable PCG Level Instance

Right-click a [[Level]] in the [[Content Browser]] > _Common_ > Scripted Asset Actions > PCG - Level To PCG Settings.
Converts all assets (What does he mean by assets? [[Static Mesh Asset]]?) to point data.
Each point carries a bunch of attributes / metadata about the static meshes in the level.
For example the [[Static Mesh Asset]] and the [[Material]].
Also information about how the [[Actor]]s were attached to each other.
These attributes / metadata is used by Static Mesh Spawner with Mesh Selector Type set to PCG Mesh Selector By Attribute.

Also has relative transform.
Tags set on the [[Actor]]s becomes a boolean attribute / metadata,
1 on the points representing an [[Actor]] that had that tag,
0 on points representing an [[Actor]] that did not have that tag.

The custom attributes / metadata setup made y PCG - Level To PCG Settings means that a new PCG graph must be created for each [[Level]] we want to turn into a PCG Level Instance.
We cannot reuse the graph or replace the root node.
We can however create helper functions, i.e. a subgraph for the actual logic and call that from all PCG Level Instance graphs.

# References

- [_Introduction to PCG Workflows in Unreal Engine 5 | Unreal Fest 2023_ by Epic Games @ youtube.com 2023](https://www.youtube.com/live/LMQDCEiLaQY)
